-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Chekc static properties of servant APIs
--   
--   A package with "test suites" to help verify that your servant APIs are
--   valid at compile-time.
--   
--   Currently the only property tested is that there are no duplicated
--   paths.
--   
--   ```haskell data DeadlySinEnum = Lust | Gluttony | Greed | Sloth |
--   Wrath | Envy | Pride
--   
--   type MathApi = "sin" :&gt; ReqBody '[JSON] Double :&gt; Post '[JSON]
--   NoContent type SatanApi = "sin" :&gt; ReqBody '[JSON] DeadlySinEnum
--   :&gt; Post '[JSON] NoContent
--   
--   type MyApi = MathApi :<a>|</a> SatanApi
--   
--   myApi :: Proxy MyApi myApi = Proxy
--   
--   validMyApi :: ValidApiTree MyApi validMyApi = validApiTree myApi ```
--   
--   ```haskell warning: [-Wdeferred-type-errors] • Duplicate method in API
--   at path /sin: <a>POST</a> • In the expression: validApiTree myApi In
--   an equation for ‘validMyApi’: validMyApi = validApiTree myApi ```
@package servant-validate
@version 0.1.0.0


-- | Internal type-level tools.
module Servant.Validate.Internal
data ApiTree
Branch :: [Symbol] -> [(Symbol, ApiTree)] -> ApiTree
type family Compare (a :: k) (b :: k) :: Ordering
type family Cases (c :: Ordering) (lt :: k) (eq :: k) (gt :: k)
type family MergeMethods err (xs :: [k]) (ys :: [k]) :: [k]
type family MergePaths (base :: [Symbol]) (xs :: [(Symbol, ApiTree)]) (ys :: [(Symbol, ApiTree)]) :: [(Symbol, ApiTree)]
type family MergeTree (base :: [Symbol]) (a :: ApiTree) (b :: ApiTree) :: ApiTree
compSym :: forall a b. () => SSym a -> SSym b -> SOrdering (CmpSymbol a b)
sMergeMethods :: forall err xs ys. () => Prod SSym xs -> Prod SSym ys -> Prod SSym (MergeMethods err xs ys)
sMergePaths :: forall base xs ys. () => Prod (Tup SSym SApiTree) xs -> Prod (Tup SSym SApiTree) ys -> Prod (Tup SSym SApiTree) (MergePaths base xs ys)
sMergeTree :: forall base a b. SApiTree a -> SApiTree b -> SApiTree (MergeTree base a b)
data SApiTree :: ApiTree -> Type
[SBranch] :: Prod SSym ms -> Prod (Tup SSym SApiTree) ts -> SApiTree ('Branch ms ts)
toSApiTree :: TypeRep api -> SApiTree api
data Prod :: (k -> Type) -> [k] -> Type
[PNil] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
data Tup :: (a -> Type) -> (b -> Type) -> (a, b) -> Type
[Tup] :: f x -> g y -> Tup f g '(x, y)
data SSym :: Symbol -> Type
[SSym] :: KnownSymbol s => SSym s
toProd :: forall k (as :: [k]) f. (forall (a :: k). TypeRep a -> f a) -> TypeRep as -> Prod f as
reflectProd :: forall k (as :: [k]) f r. (forall (a :: k). f a -> r) -> Prod f as -> [r]
toTup :: (forall x. TypeRep x -> f x) -> (forall x. TypeRep x -> g x) -> TypeRep xy -> Tup f g xy
reflectTup :: forall j k (xy :: (j, k)) f g a b. (forall (x :: j). f x -> a) -> (forall (y :: k). g y -> b) -> Tup f g xy -> (a, b)
toSSym :: TypeRep s -> SSym s
reflectSSym :: forall s. SSym s -> Text
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). GHC.Show.Show (f a)) => GHC.Show.Show (Servant.Validate.Internal.Prod f as)
instance forall a b (f :: a -> *) (g :: b -> *) (xy :: (a, b)). (forall (a1 :: a). GHC.Show.Show (f a1), forall (a1 :: b). GHC.Show.Show (g a1)) => GHC.Show.Show (Servant.Validate.Internal.Tup f g xy)
instance GHC.Show.Show (Servant.Validate.Internal.SSym s)
instance GHC.Show.Show (Servant.Validate.Internal.SApiTree api)


-- | A package with "test suites" to help verify that your servant APIs are
--   valid at compile-time. Currently the only property tested is that
--   there are no duplicated paths. See README for more information on
--   usage.
module Servant.Validate

-- | Has a valid well-formed API Tree
class HasApiTree (api :: Type) where {
    type family ToApiTree api :: ApiTree;
}

-- | Useful runtime witness of the API tree; use to inspect it with
--   <a>reflectApiTree</a>. This is not used in any part of the actual
--   validation; is just an extra treat.
sApiTree :: HasApiTree api => SApiTree (ToApiTree api)

-- | A type-level version of <a>ReflectMethod</a>.
class MethodString k where {
    type family ToMethodString (x :: k) :: Symbol;
}

-- | The full validator. To use:
--   
--   <pre>
--   serverApi :: Proxy ServerApi
--   serverApi = Proxy
--   
--   validServerApi :: ValidApiTree ServerApi
--   validServerApi = validApiTree serverApi
--   </pre>
validApiTree :: forall api. (HasApiTree api, Typeable (ToApiTree api)) => Proxy api -> ValidApiTree api

-- | To be used with <a>validApiTree</a>.
type ValidApiTree api = TypeRep (ToApiTree api)

-- | Useful utility to view the routing structure of a tree; similar to
--   <a>layout</a>.
reflectApiTree :: forall api. (HasApiTree api, Typeable (ToApiTree api)) => ApiTreeMap

-- | Version of <a>reflectApiTree</a> taking an explicit <a>TypeRep</a>.
reflectApiTree_ :: TypeRep (apiTree :: ApiTree) -> ApiTreeMap
data SApiTree :: ApiTree -> Type
[SBranch] :: Prod SSym ms -> Prod (Tup SSym SApiTree) ts -> SApiTree ('Branch ms ts)
reflectSApiTree :: SApiTree api -> ApiTreeMap
instance GHC.Classes.Ord Servant.Validate.ApiTreeMap
instance GHC.Classes.Eq Servant.Validate.ApiTreeMap
instance GHC.Show.Show Servant.Validate.ApiTreeMap
instance Servant.Validate.MethodString Network.HTTP.Types.Method.StdMethod
instance Servant.Validate.MethodString GHC.Types.Symbol
instance forall k (m :: k) (s :: GHC.Types.Nat) (t :: [*]) a. (Servant.Validate.MethodString k, GHC.TypeLits.KnownSymbol (Servant.Validate.ToMethodString m)) => Servant.Validate.HasApiTree (Servant.API.Verbs.Verb m s t a)
instance (GHC.TypeLits.KnownSymbol path, Servant.Validate.HasApiTree api) => Servant.Validate.HasApiTree (path Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Capture.Capture' mods sym a Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Capture.CaptureAll sym v Servant.API.Sub.:> api)
instance (Servant.Validate.HasApiTree a, Servant.Validate.HasApiTree b) => Servant.Validate.HasApiTree (a Servant.API.Alternative.:<|> b)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Description.Summary s Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Description.Description s Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.QueryParam.QueryFlag s Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.QueryParam.QueryParams s a Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api)
instance forall k api (mods :: [*]) (sym :: GHC.Types.Symbol) (a :: k). Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Data.Vault.Lazy.Vault Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.BasicAuth.BasicAuth realm a Servant.API.Sub.:> api)
instance forall k api (tag :: k). Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.ReqBody.ReqBody' mods ct a Servant.API.Sub.:> api)
instance Servant.Validate.HasApiTree api => Servant.Validate.HasApiTree (Servant.API.Stream.StreamBody' mods framing ct a Servant.API.Sub.:> api)
